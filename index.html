<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no, viewport-fit=cover" />
<title>Gyro Dot Target Game (final)</title>

<!-- PWA manifest (optional) -->
<link rel="manifest" href="/manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
  :root{
    --bg:#f7f7f9;
    --dot-size:36px;
    --corner-pad:16px;
  }
  html,body{height:100%;width:100%;margin:0;padding:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  #arena{position:fixed;inset:0;overflow:hidden;background:var(--bg);display:flex;align-items:center;justify-content:center}
  canvas#targetCanvas{position:absolute;left:0;top:0;width:100%;height:100%;}
  #dot{position:absolute;width:var(--dot-size);height:var(--dot-size);border-radius:50%;background:#0575e6;transform:translate(-50%,-50%);box-shadow:0 6px 12px rgba(5,117,230,0.18);z-index:25;pointer-events:none}
  .ui-pill{position:fixed;top:calc(env(safe-area-inset-top,0px) + var(--corner-pad));background:rgba(255,255,255,0.9);padding:8px 12px;border-radius:10px;font-weight:700;z-index:30;box-shadow:0 8px 24px rgba(0,0,0,0.04)}
  #scoreDisplay{left:calc(env(safe-area-inset-left,0px) + var(--corner-pad))}
  #timerDisplay{right:calc(env(safe-area-inset-right,0px) + var(--corner-pad))}
  .center-btn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:40;padding:12px 18px;border-radius:12px;border:0;background:#0575e6;color:#fff;font-weight:800;box-shadow:0 10px 28px rgba(5,117,230,0.12)}
  #calibrateBtn{background:#111}
  /* overlays */
  #rotateOverlay,#gameOverOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:60;background:rgba(255,255,255,0.98)}
  #gameOverCard{width:min(720px,92%);background:#fff;border-radius:12px;padding:20px;box-shadow:0 12px 36px rgba(0,0,0,0.08);text-align:center}
  #finalScoreBig{font-size:40px;font-weight:800;margin-bottom:8px}
  .btnPrimary{background:#0575e6;color:#fff;border:0;padding:10px 14px;border-radius:10px;font-weight:700}
  .btnSecondary{background:#f0f0f0;color:#111;border:0;padding:10px 14px;border-radius:10px;font-weight:700}
  #overlayButtons{display:flex;gap:12px;justify-content:center;margin-bottom:8px}
  #saveNameRow{display:none;margin-top:10px;gap:8px;justify-content:center;align-items:center}
  #nameInput{padding:8px 10px;border-radius:8px;border:1px solid #e6e6e6;min-width:170px}
  /* leaderboard */
  #leaderboardContainer{margin-top:12px;border-radius:8px;overflow:hidden;border:1px solid #eee;background:#fff}
  table#leaderboardTable{width:100%;border-collapse:collapse;font-size:15px}
  thead th{background:#0575e6;color:#fff;padding:12px 14px;font-weight:700;text-align:center}
  tbody td{padding:12px 14px;border-bottom:1px solid #f2f5ff;color:#111}
  td.rank{width:72px}
  td.score{text-align:right;width:110px}
  tbody tr:nth-child(even){background:#fbfdff}
  .smallNote{color:#666;margin-top:10px;font-size:13px}
</style>
</head>
<body>
  <div id="arena">
    <canvas id="targetCanvas"></canvas>
    <div id="dot" aria-hidden="true"></div>

    <div id="scoreDisplay" class="ui-pill">Score: 0</div>
    <div id="timerDisplay" class="ui-pill">30</div>

    <button id="btn" class="center-btn">Enable Gyro</button>
    <button id="calibrateBtn" class="center-btn" style="display:none">Calibrate</button>

    <!-- rotate overlay -->
    <div id="rotateOverlay">
      <div>
        <div style="font-size:18px;color:#222;text-align:center;margin-bottom:8px">Please rotate your device to <strong>landscape (home button / speaker to the right)</strong>.</div>
        <div style="text-align:center;color:#666">For best results install as PWA (Add to Home Screen) and open from Home Screen.</div>
      </div>
    </div>

    <!-- game over overlay -->
    <div id="gameOverOverlay" aria-hidden="true">
      <div id="gameOverCard">
        <div id="finalScoreBig">Score: 0</div>

        <div id="overlayButtons">
          <button id="retryBtn" class="btnPrimary">Retry</button>
          <button id="saveBtn" class="btnSecondary">Save score</button>
        </div>

        <div id="saveNameRow">
          <input id="nameInput" placeholder="Your name" />
          <button id="confirmSave" class="btnPrimary">Save</button>
        </div>

        <div id="leaderboardContainer">
          <table id="leaderboardTable" aria-label="Leaderboard">
            <thead>
              <tr><th>Rank</th><th>Name</th><th>Score</th></tr>
            </thead>
            <tbody id="leaderboardBody"></tbody>
          </table>
        </div>

        <div class="smallNote">Scores are stored locally on this device.</div>
      </div>
    </div>
  </div>

<script>
/* ---------- Config ---------- */
const LB_KEY = 'tilt_dot_leaderboard_final_v1';
const GAME_DURATION = 30;
const DOT_RADIUS = 18;
const MAX_TILT = 30; // degrees mapping to full width/height
const ringRadii = [30, 60, 90];
const maxPointsPerSecond = 10;

/* ---------- Elements ---------- */
const arena = document.getElementById('arena');
const canvas = document.getElementById('targetCanvas');
const ctx = canvas.getContext('2d');
const dotEl = document.getElementById('dot');
const scoreDisplay = document.getElementById('scoreDisplay');
const timerDisplay = document.getElementById('timerDisplay');
const enableBtn = document.getElementById('btn');
const calibrateBtn = document.getElementById('calibrateBtn');
const rotateOverlay = document.getElementById('rotateOverlay');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const finalScoreBig = document.getElementById('finalScoreBig');
const retryBtn = document.getElementById('retryBtn');
const saveBtn = document.getElementById('saveBtn');
const saveNameRow = document.getElementById('saveNameRow');
const nameInput = document.getElementById('nameInput');
const confirmSave = document.getElementById('confirmSave');
const leaderboardBody = document.getElementById('leaderboardBody');

/* ---------- State ---------- */
let arenaRect = arena.getBoundingClientRect();
function sizeCanvas(){ arenaRect = arena.getBoundingClientRect(); canvas.width = Math.round(arenaRect.width); canvas.height = Math.round(arenaRect.height); }
sizeCanvas();

let targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
let dotPos = { x: targetCenter.x, y: targetCenter.y };
let dotPos0 = {...dotPos};
let beta0 = 0, gamma0 = 0;
let lastBeta = 0, lastGamma = 0;

let score = 0;
let lastTime = 0;
let timeLeft = GAME_DURATION;
let gameActive = false;

/* Detect iPad (covers iPadOS desktop UA too) */
const isIpad = (navigator.userAgent.includes('iPad') || (navigator.userAgent.includes('Macintosh') && navigator.maxTouchPoints > 1));

/* ---------- Helpers ---------- */
function clamp(v,a,b){ return Math.min(Math.max(v,a),b); }
function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch])); }

/* ---------- Leaderboard ---------- */
function loadLeaderboard(){ try{ return JSON.parse(localStorage.getItem(LB_KEY) || '[]').sort((a,b)=>b.score - a.score); }catch(e){ return []; } }
function saveLocalScore(name, sc){ const list = loadLeaderboard(); list.push({ name: String(name||'Player'), score: Math.floor(sc), date: Date.now() }); list.sort((a,b)=>b.score - a.score); localStorage.setItem(LB_KEY, JSON.stringify(list.slice(0,50))); }
function renderLeaderboard(){ const list = loadLeaderboard().slice(0,50); leaderboardBody.innerHTML = ''; if(list.length === 0){ leaderboardBody.innerHTML = `<tr><td colspan="3" style="text-align:center;padding:18px;color:#666">No scores yet</td></tr>`; return; } list.forEach((r,i)=>{ const tr = document.createElement('tr'); tr.innerHTML = `<td class="rank">${i+1}</td><td>${escapeHtml(r.name)}</td><td class="score">${r.score}</td>`; leaderboardBody.appendChild(tr); }); }

/* ---------- Draw target ---------- */
function drawTargetAndRings(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.strokeStyle='rgba(0,0,0,0.16)'; ctx.lineWidth=2; ringRadii.forEach(r=>{ ctx.beginPath(); ctx.arc(targetCenter.x,targetCenter.y,r,0,Math.PI*2); ctx.stroke(); }); ctx.fillStyle='#ff5c5c'; ctx.beginPath(); ctx.arc(targetCenter.x,targetCenter.y,6,0,Math.PI*2); ctx.fill(); }

/* ---------- Update Loop ---------- */
function updateLoop(){
  const now = performance.now();
  const dt = lastTime ? (now - lastTime)/1000 : 0;
  lastTime = now;
  if(gameActive){
    drawTargetAndRings();
    const dx = dotPos.x - targetCenter.x;
    const dy = dotPos.y - targetCenter.y;
    const dist = Math.hypot(dx,dy);
    if(dist <= ringRadii[ringRadii.length-1]){
      score += maxPointsPerSecond * (1 - dist / ringRadii[ringRadii.length-1]) * dt;
    }
    scoreDisplay.textContent = 'Score: ' + Math.floor(score);
    timeLeft -= dt;
    if(timeLeft <= 0){ timeLeft = 0; endGame(); }
    timerDisplay.textContent = Math.ceil(timeLeft);
  }
  requestAnimationFrame(updateLoop);
}
updateLoop();

/* ---------- Orientation mapping ---------- */
/**
 * Map beta/gamma (relative) to dx/dy depending on device and screen orientation.
 * dx -> positive = right, dy -> positive = down
 */
function mapOrientationToXY(beta, gamma){
  const angle = screen.orientation?.angle ?? window.orientation ?? 0;
  let dx = 0, dy = 0;

  if(isIpad){
    // iPad Type B mapping (user reported behavior); produce intended controls:
    // forward tilt -> up, right tilt -> right in landscape-right.
    switch(angle){
      case 90:   // landscape-right (home button/speaker to the right)
        dx = gamma;      // right tilt -> right
        dy = -beta;      // forward tilt -> up
        break;
      case -90:
      case 270:  // landscape-left
        dx = -gamma;
        dy = beta;
        break;
      case 180:
        dx = -beta;
        dy = gamma;
        break;
      default:   // portrait
        dx = beta;
        dy = -gamma;
    }
  } else {
    // iPhone mapping (previous working mapping)
    switch(angle){
      case 90:   // landscape-right
        dx = beta;
        dy = -gamma;
        break;
      case -90:
      case 270:
        dx = -beta;
        dy = gamma;
        break;
      case 180:
        dx = -gamma;
        dy = -beta;
        break;
      default:
        dx = gamma;
        dy = beta;
    }
  }

  return { dx, dy };
}

/* ---------- Gyro handler (relative to calibration) ---------- */
function handleOrientation(e){
  // always capture latest for calibration even if not running
  lastBeta = (typeof e.beta === 'number') ? e.beta : lastBeta;
  lastGamma = (typeof e.gamma === 'number') ? e.gamma : lastGamma;

  if(!gameActive) return;

  const relBeta = (typeof e.beta === 'number' ? e.beta : 0) - beta0;
  const relGamma = (typeof e.gamma === 'number' ? e.gamma : 0) - gamma0;
  const { dx, dy } = mapOrientationToXY(relBeta, relGamma);

  const scaleX = arenaRect.width / MAX_TILT;
  const scaleY = arenaRect.height / MAX_TILT;

  dotPos.x = clamp(dotPos0.x + dx * scaleX, DOT_RADIUS, arenaRect.width - DOT_RADIUS);
  dotPos.y = clamp(dotPos0.y + dy * scaleY, DOT_RADIUS, arenaRect.height - DOT_RADIUS);

  dotEl.style.left = Math.round(dotPos.x) + 'px';
  dotEl.style.top = Math.round(dotPos.y) + 'px';
}

/* capture latest even when game not active */
window.addEventListener('deviceorientation', (e) => {
  lastBeta = (typeof e.beta === 'number') ? e.beta : lastBeta;
  lastGamma = (typeof e.gamma === 'number') ? e.gamma : lastGamma;
});

/* ---------- Enable gyro (permission flow) ---------- */
enableBtn.addEventListener('click', async () => {
  // check orientation
  evaluateOrientation();

  if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
    try{
      const res = await DeviceOrientationEvent.requestPermission();
      if(res !== 'granted'){ alert('Motion permission required'); return; }
    }catch(err){
      // ignore
    }
  }
  window.addEventListener('deviceorientation', handleOrientation);
  enableBtn.style.display = 'none';
  calibrateBtn.style.display = 'block';
});

/* ---------- Calibrate (center dot visually & set neutral tilt) ---------- */
calibrateBtn.addEventListener('click', () => {
  // ensure final sizes
  sizeCanvas();
  targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };

  beta0 = lastBeta ?? 0;
  gamma0 = lastGamma ?? 0;

  dotPos0 = { x: targetCenter.x, y: targetCenter.y };
  dotPos = { ...dotPos0 };
  dotEl.style.left = dotPos.x + 'px';
  dotEl.style.top = dotPos.y + 'px';

  drawTargetAndRings();
  calibrateBtn.style.display = 'none';
  score = 0;
  timeLeft = GAME_DURATION;
  lastTime = performance.now();
  gameActive = true;
});

/* ---------- End game ---------- */
function endGame(){
  gameActive = false;
  finalScoreBig.textContent = 'Score: ' + Math.floor(score);
  renderLeaderboard();
  gameOverOverlay.style.display = 'flex';
  gameOverOverlay.setAttribute('aria-hidden','false');
}

/* ---------- Retry ---------- */
retryBtn.addEventListener('click', () => {
  gameOverOverlay.style.display = 'none';
  gameOverOverlay.setAttribute('aria-hidden','true');
  saveNameRow.style.display = 'none';
  nameInput.value = '';
  enableBtn.style.display = 'block';
  calibrateBtn.style.display = 'none';
  sizeCanvas();
  targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
  dotPos = { x: targetCenter.x, y: targetCenter.y };
  dotPos0 = { ...dotPos };
  dotEl.style.left = dotPos.x + 'px';
  dotEl.style.top = dotPos.y + 'px';
  score = 0;
  timeLeft = GAME_DURATION;
  lastTime = 0;
  scoreDisplay.textContent = 'Score: 0';
  timerDisplay.textContent = GAME_DURATION;
});

/* ---------- Save score ---------- */
saveBtn.addEventListener('click', ()=>{ saveNameRow.style.display = 'flex'; nameInput.focus(); });
confirmSave.addEventListener('click', ()=> {
  const name = (nameInput.value || 'Player').trim();
  if(!name){ alert('Please enter a name'); nameInput.focus(); return; }
  saveLocalScore(name, score);
  saveNameRow.style.display = 'none';
  nameInput.value = '';
  renderLeaderboard();
});

/* ---------- Leaderboard render helper ---------- */
function renderLeaderboard(){ // already defined above; call to update DOM
  const list = loadLeaderboard().slice(0,50);
  leaderboardBody.innerHTML = '';
  if(list.length === 0){
    leaderboardBody.innerHTML = `<tr><td colspan="3" style="text-align:center;padding:18px;color:#666">No scores yet</td></tr>`;
    return;
  }
  list.forEach((r,i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class="rank">${i+1}</td><td>${escapeHtml(r.name)}</td><td class="score">${r.score}</td>`;
    leaderboardBody.appendChild(tr);
  });
}

/* ---------- Orientation UI & resize handling ---------- */
function evaluateOrientation(){
  const w = window.innerWidth, h = window.innerHeight;
  const isLandscape = w >= h;
  if(!isLandscape){
    rotateOverlay.style.display = 'flex';
    // block calibrate/start until landscape
    // enableBtn may remain visible (permission can still be granted), but gameplay blocked
    return false;
  } else {
    rotateOverlay.style.display = 'none';
    return true;
  }
}

window.addEventListener('orientationchange', ()=> {
  setTimeout(()=> {
    sizeCanvas();
    targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
    // if game not active, center dot exactly
    if(!gameActive){
      dotPos = { x: targetCenter.x, y: targetCenter.y };
      dotPos0 = { ...dotPos };
      dotEl.style.left = dotPos.x + 'px';
      dotEl.style.top = dotPos.y + 'px';
      drawTargetAndRings();
    } else { // clamp if active
      dotPos.x = clamp(dotPos.x, DOT_RADIUS, arenaRect.width - DOT_RADIUS);
      dotPos.y = clamp(dotPos.y, DOT_RADIUS, arenaRect.height - DOT_RADIUS);
      dotEl.style.left = dotPos.x + 'px';
      dotEl.style.top = dotPos.y + 'px';
      drawTargetAndRings();
    }
    evaluateOrientation();
  }, 120);
});

window.addEventListener('resize', ()=> {
  sizeCanvas();
  targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
  drawTargetAndRings();
});

/* ---------- Init ---------- */
(function init(){
  sizeCanvas();
  targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
  dotPos = { x: targetCenter.x, y: targetCenter.y };
  dotPos0 = { ...dotPos };
  dotEl.style.left = dotPos.x + 'px';
  dotEl.style.top = dotPos.y + 'px';
  drawTargetAndRings();
  renderLeaderboard(); // not shown until gameOver overlay visible
  evaluateOrientation();
  calibrateBtn.style.display = 'none';
  gameOverOverlay.style.display = 'none';
})();

</script>
</body>
</html>
