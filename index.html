<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no, viewport-fit=cover" />
<title>Gyro Dot Target Game (final)</title>

<!-- PWA manifest (optional) -->
<link rel="manifest" href="/manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- ★ NEW: Confetti library -->
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

<style>
:root{
  --bg:#0b1226;
  --dot-size:38px;
  --corner-pad:16px;
}
html,body{height:100%;width:100%;margin:0;padding:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
#arena{position:fixed;inset:0;overflow:hidden;background:var(--bg);display:flex;align-items:center;justify-content:center}
  canvas#targetCanvas{position:absolute;left:0;top:0;width:100%;height:100%;display:none}
#dot{position:absolute;width:var(--dot-size);height:var(--dot-size);border-radius:50%;background:#19f6ff;transform:translate(-50%,-50%);box-shadow:0 0 22px rgba(25,246,255,0.9),0 0 44px rgba(25,246,255,0.4);z-index:50;pointer-events:none;display:none}
  .ui-pill{position:fixed;top:calc(env(safe-area-inset-top,0px) + var(--corner-pad));background:rgba(255,255,255,0.95);padding:20px 32px;border-radius:16px;font-weight:800;font-size:36px;z-index:30;box-shadow:0 8px 32px rgba(0,0,0,0.08);display:none;letter-spacing:-0.5px}
  #scoreDisplay{left:calc(env(safe-area-inset-left,0px) + var(--corner-pad))}
  #timerDisplay{right:calc(env(safe-area-inset-right,0px) + var(--corner-pad))}
  .center-btn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:40;padding:20px 48px;border-radius:16px;border:0;background:#0575e6;color:#fff;font-weight:800;font-size:20px;box-shadow:0 12px 40px rgba(5,117,230,0.25);cursor:pointer;transition:all 0.2s ease;letter-spacing:0.5px;min-width:240px}
  .center-btn:hover{background:#0468d4;transform:translate(-50%,-50%) scale(1.02);box-shadow:0 16px 48px rgba(5,117,230,0.35)}
  .center-btn:active{transform:translate(-50%,-50%) scale(0.98)}
  #calibrateBtn{background:#0575e6;box-shadow:0 12px 40px rgba(5,117,230,0.25)}
  #calibrateBtn:hover{background:#0468d4;box-shadow:0 16px 48px rgba(5,117,230,0.35)}

  /* overlays */
  #rotateOverlay,#gameOverOverlay,#countdownOverlay{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:60;background:rgba(255,255,255,0.98)
  }

  /* countdown circle container */
  #countdownContainer{
    text-align:center;
    position:relative;
  }

  #countdownNumber{
    font-size:80px;
    font-weight:800;
    color:#111;
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
  }

  /* circular ring animation */
  .countdown-ring{
    width:160px;
    height:160px;
    border-radius:50%;
    border:10px solid #e6e6e6;
    position:relative;
    overflow:hidden;
  }

  .countdown-fill{
    position:absolute;
    inset:0;
    border-radius:50%;
    border:10px solid #0575e6;
    transform-origin:center;
    transform:rotate(0deg);
    transition:transform 1s linear;
  }

  #gameOverCard{width:min(720px,92%);background:#fff;border-radius:12px;padding:20px;box-shadow:0 12px 36px rgba(0,0,0,0.08);text-align:center}
  #finalScoreBig{font-size:40px;font-weight:800;margin-bottom:8px}
  .btnPrimary{background:#0575e6;color:#fff;border:0;padding:10px 14px;border-radius:10px;font-weight:700}
  .btnSecondary{background:#f0f0f0;color:#111;border:0;padding:10px 14px;border-radius:10px;font-weight:700}
  #overlayButtons{display:flex;gap:12px;justify-content:center;margin-bottom:8px}
  #saveNameRow{display:none;margin-top:10px;gap:8px;justify-content:center;align-items:center}
  #nameInput{padding:8px 10px;border-radius:8px;border:1px solid #e6e6e6;min-width:170px}

  /* leaderboard */
  #leaderboardContainer{margin-top:12px;border-radius:8px;overflow:hidden;border:1px solid #eee;background:#fff}
  table#leaderboardTable{width:100%;border-collapse:collapse;font-size:15px}
  thead th{background:#0575e6;color:#fff;padding:12px 14px;font-weight:700;text-align:center}
  tbody td{padding:12px 14px;border-bottom:1px solid #f2f5ff;color:#111}
  td.rank{width:72px}
  td.score{text-align:right;width:110px}
  tbody tr:nth-child(even){background:#fbfdff}
  .smallNote{color:#666;margin-top:10px;font-size:13px}

  /* level selection menu */
  #levelSelectionMenu{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:40;background:#fff;border-radius:20px;padding:32px;box-shadow:0 16px 48px rgba(0,0,0,0.15);display:none;min-width:280px;text-align:center}
  #levelSelectionMenu h2{margin:0 0 24px 0;font-size:24px;font-weight:800;color:#111}
  .level-btn{display:block;width:100%;padding:18px 24px;margin-bottom:12px;border-radius:14px;border:0;background:#0575e6;color:#fff;font-weight:700;font-size:18px;cursor:pointer;transition:all 0.2s ease;box-shadow:0 8px 24px rgba(5,117,230,0.2)}
  .level-btn:hover{background:#0468d4;transform:scale(1.02);box-shadow:0 12px 32px rgba(5,117,230,0.3)}
  .level-btn:active{transform:scale(0.98)}
  .level-btn:last-child{margin-bottom:0}
  .level-description{font-size:14px;color:#666;margin-top:6px;font-weight:400}
</style>
<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
<script>
  // Your Firebase project configuration for "gibbon-balance-game"
  const firebaseConfig = {
    apiKey: "AIzaSyA7BZvLHuIXiYdukRpV7bM52pBBuWzv3rU", // <--- PASTE YOUR API KEY HERE
    authDomain: "gibbon-balance-game.firebaseapp.com",
    projectId: "gibbon-balance-game",
    storageBucket: "gibbon-balance-game.firebasestorage.app",
    messagingSenderId: "435375118778",
    appId: "1:435375118778:web:5513fc213d8d7fef816583" // <--- PASTE YOUR APP ID HERE
  };

  // Initialize Firebase and get Firestore instance
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // Function to save score to Firebase
  async function saveFirebaseScore(name, sc, level) {
    let collectionRef = db.collection('leaderboardLevel1');
    if(level === 2){ collectionRef = db.collection('leaderboardLevel2'); }
    if(level === 3){ collectionRef = db.collection('leaderboardSurvival'); }
    try {
      await collectionRef.add({
        playerName: String(name || 'Player').trim(),
        score: Math.floor(sc),
        timestamp: firebase.firestore.FieldValue.serverTimestamp() // Server timestamp for consistent ordering
      });
      console.log(`Score ${Math.floor(sc)} by ${name} saved to Firebase for Level ${level}.`);
    } catch (error) {
      console.error("Error saving score to Firebase: ", error);
      // For MVP, just log the error. In production, you might show a message.
    }
  }
</script>
</head>
<body>
  <div id="arena">
    <canvas id="targetCanvas"></canvas>
    <div id="dot" aria-hidden="true"></div>

    <div id="scoreDisplay" class="ui-pill">Score: 0</div>
    <div id="timerDisplay" class="ui-pill">30</div>

    <button id="btn" class="center-btn">Enable Gyro</button>
    <button id="calibrateBtn" class="center-btn" style="display:none">Calibrate</button>

    <!-- level selection menu -->
    <div id="levelSelectionMenu">
      <h2>Select Game Mode</h2>
      <button class="level-btn" data-level="1">
        Level 1 - Static Mode
        <div class="level-description">Fixed target in center</div>
      </button>
      <button class="level-btn" data-level="2">
        Level 2 - Moving Target
        <div class="level-description">Target moves across screen</div>
      </button>
      <button class="level-btn" data-level="3">
        Survival Arena
        <div class="level-description">Dodge obstacles as long as you can</div>
      </button>
    </div>

    <!-- rotate overlay -->
    <div id="rotateOverlay">
      <div>
        <div style="font-size:18px;color:#222;text-align:center;margin-bottom:8px">Please rotate your device to <strong>landscape (home button / speaker to the right)</strong>.</div>
        <div style="text-align:center;color:#666">For best results install as PWA (Add to Home Screen) and open from Home Screen.</div>
      </div>
    </div>

    <!-- countdown overlay -->
    <div id="countdownOverlay">
      <div id="countdownContainer">
        <div class="countdown-ring">
          <div class="countdown-fill" id="countdownFill"></div>
        </div>
        <div id="countdownNumber">3</div>
      </div>
    </div>

    <!-- game over overlay -->
    <div id="gameOverOverlay" aria-hidden="true">
      <div id="gameOverCard">
        <div id="finalScoreBig">Score: 0</div>

        <div id="overlayButtons">
          <button id="retryBtn" class="btnPrimary">Retry</button>
          <button id="saveBtn" class="btnSecondary">Save score</button>
        </div>

        <div id="saveNameRow">
          <input id="nameInput" placeholder="Your name" />
          <button id="confirmSave" class="btnPrimary">Save</button>
        </div>

        <div id="leaderboardContainer">
          <table id="leaderboardTable" aria-label="Leaderboard">
            <thead>
              <tr><th>Rank</th><th>Name</th><th>Score</th></tr>
            </thead>
            <tbody id="leaderboardBody"></tbody>
          </table>
        </div>

        <div class="smallNote">Scores are stored locally on this device.</div>
      </div>
    </div>
  </div>

<script>
/* ---------- Config ---------- */
const LB_KEY_LEVEL1 = 'tilt_dot_leaderboard_level1_v1';
const LB_KEY_LEVEL2 = 'tilt_dot_leaderboard_level2_v1';
const LB_KEY_LEVEL3 = 'tilt_dot_leaderboard_level3_v1'; // Survival
const GAME_DURATION = 30;
const DOT_RADIUS = 18;
const MAX_TILT = 30; 
const ringRadii = [50, 100, 150];
const maxPointsPerSecond = 30;
const TARGET_MOVE_SPEED = 80; // pixels per second for Level 2
const SURVIVAL_SEED = 123456;
const SURVIVAL_SCORE_MULT = 10;
const SURVIVAL_MAX_OBS = 40;
const SURVIVAL_BASE_SPEED = 88;
const SURVIVAL_SPEED_GAIN = 85;
const SURVIVAL_ROT_GAIN = 0.52; // base rad/s
const SURVIVAL_LEN_MIN = 90;
const SURVIVAL_LEN_MAX = 160;
const SURVIVAL_BG = '#0d1024';
const SURVIVAL_COLORS = ['#ff5fad', '#ff9f43', '#7eff6b', '#9b7bff', '#ffde59'];
const SURVIVAL_LINE_COLOR = '#f26bff';

/* ---------- Elements ---------- */
const arena = document.getElementById('arena');
const canvas = document.getElementById('targetCanvas');
const ctx = canvas.getContext('2d');
const dotEl = document.getElementById('dot');
const scoreDisplay = document.getElementById('scoreDisplay');
const timerDisplay = document.getElementById('timerDisplay');
const enableBtn = document.getElementById('btn');
const calibrateBtn = document.getElementById('calibrateBtn');
const levelSelectionMenu = document.getElementById('levelSelectionMenu');
const levelButtons = document.querySelectorAll('.level-btn');
const rotateOverlay = document.getElementById('rotateOverlay');
const countdownOverlay = document.getElementById('countdownOverlay');
const countdownNumber = document.getElementById('countdownNumber');
const countdownFill = document.getElementById('countdownFill');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const finalScoreBig = document.getElementById('finalScoreBig');
const retryBtn = document.getElementById('retryBtn');
const saveBtn = document.getElementById('saveBtn');
const saveNameRow = document.getElementById('saveNameRow');
const nameInput = document.getElementById('nameInput');
const confirmSave = document.getElementById('confirmSave');
const leaderboardBody = document.getElementById('leaderboardBody');

/* ---------- State ---------- */
let arenaRect = arena.getBoundingClientRect();
function sizeCanvas(){ arenaRect = arena.getBoundingClientRect(); canvas.width = Math.round(arenaRect.width); canvas.height = Math.round(arenaRect.height); }
sizeCanvas();

let targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
let dotPos = { x: targetCenter.x, y: targetCenter.y };
let dotPos0 = {...dotPos};
let beta0 = 0, gamma0 = 0;
let lastBeta = 0, lastGamma = 0;

let score = 0;
let lastTime = 0;
let timeLeft = GAME_DURATION;
let gameActive = false;
let currentLevel = 1; // 1 = static, 2 = moving target, 3 = survival
let targetVelocity = { x: 0, y: 0 }; // For Level 2 moving target
let survival = {
  rng: null,
  time: 0,
  shapes: [],
  lines: [],
  circleSpawn: 0,
  lineSpawn: 0
};

/* detect iPad */
const isIpad = (navigator.userAgent.includes('iPad') || (navigator.userAgent.includes('Macintosh') && navigator.maxTouchPoints > 1));

/* ---------- Helpers ---------- */
function clamp(v,a,b){ return Math.min(Math.max(v,a),b); }
function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch])); }
function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
function lerp(a,b,t){ return a + (b-a)*t; }

/* ---------- Leaderboard ---------- */
function getLeaderboardKey(level){
  if(level === 1) return LB_KEY_LEVEL1;
  if(level === 2) return LB_KEY_LEVEL2;
  return LB_KEY_LEVEL3;
}
function loadLeaderboard(level){ const key = getLeaderboardKey(level); try{ return JSON.parse(localStorage.getItem(key) || '[]').sort((a,b)=>b.score - a.score); }catch(e){ return []; } }
function saveLocalScore(name, sc, level){ const key = getLeaderboardKey(level); const list = loadLeaderboard(level); list.push({ name: String(name||'Player'), score: Math.floor(sc), date: Date.now() }); list.sort((a,b)=>b.score - a.score); localStorage.setItem(key, JSON.stringify(list.slice(0,50))); }
function renderLeaderboard(level){ const list = loadLeaderboard(level).slice(0,50); leaderboardBody.innerHTML = ''; if(list.length === 0){ leaderboardBody.innerHTML = `<tr><td colspan="3" style="text-align:center;padding:18px;color:#666">No scores yet</td></tr>`; return; } list.forEach((r,i)=>{ const tr=document.createElement('tr'); tr.innerHTML = `<td class="rank">${i+1}</td><td>${escapeHtml(r.name)}</td><td class="score">${r.score}</td>`; leaderboardBody.appendChild(tr); }); }

/* ---------- Canvas drawing ---------- */
function drawTargetAndRings(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle='rgba(61,226,255,0.7)';
  ctx.lineWidth=3;
  ringRadii.forEach(r=>{
    ctx.beginPath();
    ctx.arc(targetCenter.x,targetCenter.y,r,0,Math.PI*2);
    ctx.stroke();
  });
  ctx.fillStyle='#ff7a7a';
  ctx.shadowColor = '#ff7a7a';
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.arc(targetCenter.x,targetCenter.y,6,0,Math.PI*2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

/* ---------- Moving target logic (Level 2) ---------- */
function initMovingTarget(){
  // Start target at center
  targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
  
  // Random initial velocity
  const angle = Math.random() * Math.PI * 2;
  const speed = TARGET_MOVE_SPEED;
  targetVelocity.x = Math.cos(angle) * speed;
  targetVelocity.y = Math.sin(angle) * speed;
}

function updateMovingTarget(dt){
  if(currentLevel !== 2) return;
  
  // Update position
  targetCenter.x += targetVelocity.x * dt;
  targetCenter.y += targetVelocity.y * dt;
  
  // Bounce off edges (with margin for rings)
  const margin = ringRadii[ringRadii.length - 1] + 10;
  if(targetCenter.x <= margin || targetCenter.x >= arenaRect.width - margin){
    targetVelocity.x *= -1;
    targetCenter.x = clamp(targetCenter.x, margin, arenaRect.width - margin);
  }
  if(targetCenter.y <= margin || targetCenter.y >= arenaRect.height - margin){
    targetVelocity.y *= -1;
    targetCenter.y = clamp(targetCenter.y, margin, arenaRect.height - margin);
  }
}

/* ---------- Survival mode (Level 3) ---------- */
function resetSurvival(){
  const runSeed = (SURVIVAL_SEED + Math.floor(Math.random()*1_000_000_000)) >>> 0;
  survival.rng = mulberry32(runSeed);
  survival.time = 0;
  survival.shapes = [];
  survival.lines = [];
  survival.circleSpawn = 0;
  survival.lineSpawn = 6; // delay lines
  ctx.clearRect(0,0,canvas.width,canvas.height);
}

function spawnShape(){
  if(!survival.rng) return;
  const edge = Math.floor(survival.rng()*4);
  const size = lerp(18, 30, survival.rng());
  let x=0,y=0;
  if(edge === 0){ x = -size*2; y = survival.rng()*canvas.height; }
  else if(edge === 1){ x = canvas.width + size*2; y = survival.rng()*canvas.height; }
  else if(edge === 2){ x = survival.rng()*canvas.width; y = -size*2; }
  else { x = survival.rng()*canvas.width; y = canvas.height + size*2; }

  // Aim roughly toward center with small offset
  const angleToCenter = Math.atan2(canvas.height/2 - y, canvas.width/2 - x);
  const spread = (survival.rng()-0.5) * 0.7;
  const difficulty = 1 + survival.time / 220; // unbounded ramp, slow early
  const speed = SURVIVAL_BASE_SPEED + SURVIVAL_SPEED_GAIN * Math.log1p(difficulty);
  const vx = Math.cos(angleToCenter + spread) * speed;
  const vy = Math.sin(angleToCenter + spread) * speed;

  const shapeTypeRoll = survival.rng();
  const type = shapeTypeRoll < 0.33 ? 'circle' : shapeTypeRoll < 0.66 ? 'square' : 'triangle';
  const color = SURVIVAL_COLORS[Math.floor(survival.rng()*SURVIVAL_COLORS.length)];
  const rot = survival.rng() * Math.PI * 2;
  const rotVel = (survival.rng()*1.2 - 0.6) * SURVIVAL_ROT_GAIN * difficulty; // playful spin scales over time
  survival.shapes.push({ x, y, r: size, vx, vy, type, color, rot, rotVel });
}

function spawnLine(){
  if(!survival.rng) return;
  const side = Math.floor(survival.rng()*4); // 0 left, 1 right, 2 top, 3 bottom
  const margin = 80;
  const length = lerp(SURVIVAL_LEN_MIN, SURVIVAL_LEN_MAX, survival.rng());
  let cx=0, cy=0, vx=0, vy=0;
  const difficulty = 1 + survival.time / 220;
  const driftSpeed = SURVIVAL_BASE_SPEED * 0.7 + SURVIVAL_SPEED_GAIN * 0.5 * Math.log1p(difficulty);
  if(side === 0){
    cx = -margin; cy = lerp(-margin, canvas.height + margin, survival.rng());
    vx = driftSpeed; vy = (survival.rng()-0.5) * driftSpeed * 0.25;
  } else if(side === 1){
    cx = canvas.width + margin; cy = lerp(-margin, canvas.height + margin, survival.rng());
    vx = -driftSpeed; vy = (survival.rng()-0.5) * driftSpeed * 0.25;
  } else if(side === 2){
    cx = lerp(-margin, canvas.width + margin, survival.rng()); cy = -margin;
    vy = driftSpeed; vx = (survival.rng()-0.5) * driftSpeed * 0.25;
  } else {
    cx = lerp(-margin, canvas.width + margin, survival.rng()); cy = canvas.height + margin;
    vy = -driftSpeed; vx = (survival.rng()-0.5) * driftSpeed * 0.25;
  }

  const angleBase = Math.atan2(vy, vx);
  const angle = angleBase + (survival.rng()-0.5) * 0.5;
  const angVel = SURVIVAL_ROT_GAIN * difficulty * (survival.rng() > 0.5 ? 1 : -1);
  survival.lines.push({ cx, cy, length, angle, angVel, vx, vy });
}

function pointToSegmentDist(px, py, x1, y1, x2, y2){
  const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
  const dot = A*C + B*D;
  const lenSq = C*C + D*D;
  const t = lenSq ? clamp(dot / lenSq, 0, 1) : 0;
  const nx = x1 + C * t;
  const ny = y1 + D * t;
  const dx = px - nx;
  const dy = py - ny;
  return Math.hypot(dx, dy);
}

function updateSurvival(dt){
  survival.time += dt;
  const difficulty = 1 + survival.time / 210; // smoother ramp

  // spawn circles
  survival.circleSpawn -= dt;
  const circleInterval = 2.9 / Math.pow(difficulty, 0.58);
  if(survival.circleSpawn <= 0 && survival.shapes.length + survival.lines.length < SURVIVAL_MAX_OBS){
    spawnShape();
    survival.circleSpawn = circleInterval;
  }

  // spawn lines after short delay
  survival.lineSpawn -= dt;
  const lineInterval = 5.6 / Math.pow(difficulty, 0.54);
  if(survival.lineSpawn <= 0 && survival.shapes.length + survival.lines.length < SURVIVAL_MAX_OBS){
    spawnLine();
    survival.lineSpawn = lineInterval;
  }

  // update moving shapes
  survival.shapes.forEach(c=>{
    c.x += c.vx * dt;
    c.y += c.vy * dt;
    c.rot += c.rotVel * dt;
  });
  // keep shapes in bounds by bouncing
  survival.shapes.forEach(c=>{
    const margin = c.r;
    if(c.x < margin){ c.x = margin; c.vx = Math.abs(c.vx); }
    if(c.x > canvas.width - margin){ c.x = canvas.width - margin; c.vx = -Math.abs(c.vx); }
    if(c.y < margin){ c.y = margin; c.vy = Math.abs(c.vy); }
    if(c.y > canvas.height - margin){ c.y = canvas.height - margin; c.vy = -Math.abs(c.vy); }
  });

  // update lines
  survival.lines.forEach(l=>{
    l.cx += l.vx * dt;
    l.cy += l.vy * dt;
    l.angle += l.angVel * dt;

    const margin = 40;
    if(l.cx < margin){ l.cx = margin; l.vx = Math.abs(l.vx); }
    if(l.cx > canvas.width - margin){ l.cx = canvas.width - margin; l.vx = -Math.abs(l.vx); }
    if(l.cy < margin){ l.cy = margin; l.vy = Math.abs(l.vy); }
    if(l.cy > canvas.height - margin){ l.cy = canvas.height - margin; l.vy = -Math.abs(l.vy); }
  });

  // collision
  const dotR = DOT_RADIUS;
  const px = dotPos.x, py = dotPos.y;

  for(const c of survival.shapes){
    const hitRadius = c.type === 'circle' ? c.r : c.r * 1.1;
    if(Math.hypot(px - c.x, py - c.y) <= hitRadius + dotR){ endGame(); return; }
  }
  for(const l of survival.lines){
    const half = l.length / 2;
    const x1 = l.cx + Math.cos(l.angle) * (-half);
    const y1 = l.cy + Math.sin(l.angle) * (-half);
    const x2 = l.cx + Math.cos(l.angle) * half;
    const y2 = l.cy + Math.sin(l.angle) * half;
    if(pointToSegmentDist(px, py, x1, y1, x2, y2) <= dotR + 6){ endGame(); return; }
  }

  // scoring (survival time)
  score = survival.time * SURVIVAL_SCORE_MULT;
  scoreDisplay.textContent = 'Survival: ' + Math.floor(score);
  timerDisplay.textContent = Math.floor(survival.time) + 's';
}

function drawSurvival(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = SURVIVAL_BG;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // obstacles
  survival.shapes.forEach(c=>{
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(c.rot);
    ctx.fillStyle = c.color;
    ctx.shadowColor = c.color;
    ctx.shadowBlur = 20;
    if(c.type === 'circle'){
      ctx.beginPath();
      ctx.arc(0, 0, c.r, 0, Math.PI*2);
      ctx.fill();
    } else if(c.type === 'square'){
      const s = c.r * 1.6;
      ctx.fillRect(-s/2, -s/2, s, s);
    } else { // triangle
      const s = c.r * 1.9;
      ctx.beginPath();
      ctx.moveTo(0, -s/2);
      ctx.lineTo(-s/2, s/2);
      ctx.lineTo(s/2, s/2);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  });

  survival.lines.forEach(l=>{
    const half = l.length / 2;
    const x1 = l.cx + Math.cos(l.angle) * (-half);
    const y1 = l.cy + Math.sin(l.angle) * (-half);
    const x2 = l.cx + Math.cos(l.angle) * half;
    const y2 = l.cy + Math.sin(l.angle) * half;
    ctx.strokeStyle = SURVIVAL_LINE_COLOR;
    ctx.lineWidth = 12;
    ctx.shadowColor = SURVIVAL_LINE_COLOR;
    ctx.shadowBlur = 18;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  });
}

/* ---------- Game update loop ---------- */
function updateLoop(){
  const now = performance.now();
  const dt = lastTime ? (now-lastTime)/1000 : 0;
  lastTime = now;

  if(gameActive){
    if(currentLevel === 3){
      drawSurvival();
      updateSurvival(dt);
    } else {
      // Update moving target for Level 2
      if(currentLevel === 2){
        updateMovingTarget(dt);
      }
      
      drawTargetAndRings();
      const dx = dotPos.x - targetCenter.x;
      const dy = dotPos.y - targetCenter.y;
      const dist = Math.hypot(dx,dy);
      if(dist <= ringRadii[ringRadii.length-1]){
        score += maxPointsPerSecond * (1 - dist / ringRadii[ringRadii.length-1]) * dt;
      }
      scoreDisplay.textContent = 'Score: ' + Math.floor(score);
      timeLeft -= dt;
      if(timeLeft <= 0){ timeLeft = 0; endGame(); }
      timerDisplay.textContent = Math.ceil(timeLeft);
    }
  }

  requestAnimationFrame(updateLoop);
}
updateLoop();

/* ---------- Orientation mapping ---------- */
function mapOrientationToXY(beta,gamma){
  const angle = screen.orientation?.angle ?? window.orientation ?? 0;
  let dx=0, dy=0;

  if(isIpad){
    switch(angle){
      case 90: dx = gamma; dy = -beta; break;
      case -90: case 270: dx = -gamma; dy = beta; break;
      case 180: dx = -beta; dy = gamma; break;
      default: dx = beta; dy = -gamma;
    }
  } else {
    switch(angle){
      case 90: dx = beta; dy = -gamma; break;
      case -90: case 270: dx = -beta; dy = gamma; break;
      case 180: dx = -gamma; dy = -beta; break;
      default: dx = gamma; dy = beta;
    }
  }

  return {dx,dy};
}

/* ---------- Orientation handler ---------- */
function handleOrientation(e){
  lastBeta = (typeof e.beta === 'number') ? e.beta : lastBeta;
  lastGamma = (typeof e.gamma === 'number') ? e.gamma : lastGamma;
  if(!gameActive) return;

  const relBeta = (typeof e.beta === 'number' ? e.beta : 0) - beta0;
  const relGamma = (typeof e.gamma === 'number' ? e.gamma : 0) - gamma0;
  const {dx,dy} = mapOrientationToXY(relBeta,relGamma);

  const scaleX = arenaRect.width / MAX_TILT;
  const scaleY = arenaRect.height / MAX_TILT;

  dotPos.x = clamp(dotPos0.x + dx*scaleX, DOT_RADIUS, arenaRect.width-DOT_RADIUS);
  dotPos.y = clamp(dotPos0.y + dy*scaleY, DOT_RADIUS, arenaRect.height-DOT_RADIUS);

  dotEl.style.left = Math.round(dotPos.x)+'px';
  dotEl.style.top = Math.round(dotPos.y)+'px';
}

window.addEventListener('deviceorientation', e => {
  lastBeta = (typeof e.beta === 'number') ? e.beta : lastBeta;
  lastGamma = (typeof e.gamma === 'number') ? e.gamma : lastGamma;
});

/* ---------- Enable gyro ---------- */
enableBtn.addEventListener('click', async () => {
  evaluateOrientation();

  if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
    try{
      const res = await DeviceOrientationEvent.requestPermission();
      if(res !== 'granted'){ alert('Motion permission required'); return; }
    }catch(err){}
  }

  window.addEventListener('deviceorientation', handleOrientation);
  enableBtn.style.display = 'none';
  levelSelectionMenu.style.display = 'block';
});

/* ---------- Level selection ---------- */
levelButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    currentLevel = parseInt(btn.dataset.level);
    levelSelectionMenu.style.display = 'none';
    calibrateBtn.style.display = 'block';
  });
});

/* ---------- Countdown function ---------- */
function startCountdown(callback){
  countdownOverlay.style.display = "flex";

  let count = 3;

  function tick(){
    countdownNumber.textContent = count;

    countdownFill.style.transform = "rotate(360deg)";
    countdownFill.style.transition = "transform 1s linear";

    setTimeout(()=>{
      countdownFill.style.transition = "none";
      countdownFill.style.transform = "rotate(0deg)";
    },1000);

    if(count === 0){
      countdownNumber.textContent = "GO!";
      countdownFill.style.display = "none";

      setTimeout(()=>{
        countdownOverlay.style.display = "none";
        countdownFill.style.display = "block";
        countdownFill.style.transform = "rotate(0deg)";
        countdownFill.style.transition = "none";
        // Show game elements when countdown ends
        canvas.style.display = "block";
        dotEl.style.display = "block";
        scoreDisplay.style.display = "block";
        timerDisplay.style.display = "block";
        callback();
      },700);

      return;
    }

    count--;
    setTimeout(tick,1000);
  }

  tick();
}

/* ---------- Calibrate ---------- */
calibrateBtn.addEventListener('click', () => {
  sizeCanvas();
  
  // Initialize target based on level
  if(currentLevel === 1){
    targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
  } else if(currentLevel === 2){
    initMovingTarget();
  } else {
    resetSurvival();
  }

  beta0 = lastBeta ?? 0;
  gamma0 = lastGamma ?? 0;

  dotPos0 = { x: arenaRect.width/2, y: arenaRect.height/2 };
  dotPos = {...dotPos0};
  dotEl.style.left = dotPos.x+'px';
  dotEl.style.top = dotPos.y+'px';

  if(currentLevel === 3){
    drawSurvival();
  } else {
    drawTargetAndRings();
  }
  calibrateBtn.style.display = 'none';
  
  // Hide game elements during countdown
  canvas.style.display = "none";
  dotEl.style.display = "none";
  scoreDisplay.style.display = "none";
  timerDisplay.style.display = "none";

  startCountdown(() => {
    score = 0;
    timeLeft = GAME_DURATION;
    lastTime = performance.now();
    gameActive = true;
    
    // Reinitialize moving target when game starts
    if(currentLevel === 2){
      initMovingTarget();
    }
    if(currentLevel === 3){
      resetSurvival();
      scoreDisplay.textContent = 'Survival: 0';
      timerDisplay.textContent = '0s';
    }
  });
});

/* ---------- ★ NEW: Confetti burst function ---------- */
function fireConfetti(){
  const duration = 2200; // 2.2 seconds
  const end = Date.now() + duration;

  (function frame(){
    // top center burst, falling downward
    confetti({
      particleCount: 6,
      startVelocity: 45,
      spread: 80,
      origin: { x: 0.5, y: 0 }, // <-- top center
      angle: 90
    });

    if(Date.now() < end){
      requestAnimationFrame(frame);
    }
  })();
}

/* ---------- End game ---------- */
function endGame(){
  gameActive = false;

  // ★ Trigger confetti immediately when time ends
  fireConfetti();

  const label = currentLevel === 3 ? 'Survival Score' : 'Score';
  finalScoreBig.textContent = `${label}: ` + Math.floor(score);
  renderLeaderboard(currentLevel);
  gameOverOverlay.style.display = 'flex';
  gameOverOverlay.setAttribute('aria-hidden','false');
}

/* ---------- Retry ---------- */
retryBtn.addEventListener('click', () => {
  gameOverOverlay.style.display = 'none';
  gameOverOverlay.setAttribute('aria-hidden','true');
  saveNameRow.style.display = 'none';
  nameInput.value = '';

  enableBtn.style.display = 'block';
  calibrateBtn.style.display = 'none';
  levelSelectionMenu.style.display = 'none';

  sizeCanvas();
  targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
  dotPos = { x: targetCenter.x, y: targetCenter.y };
  dotPos0 = {...dotPos};

  dotEl.style.left = dotPos.x+'px';
  dotEl.style.top = dotPos.y+'px';

  // Hide game elements when retrying
  canvas.style.display = "none";
  dotEl.style.display = "none";
  scoreDisplay.style.display = "none";
  timerDisplay.style.display = "none";

  score = 0;
  timeLeft = GAME_DURATION;
  lastTime = 0;
  currentLevel = 1; // Reset to level 1

  scoreDisplay.textContent = 'Score: 0';
  timerDisplay.textContent = GAME_DURATION;
});

/* ---------- Save score ---------- */
saveBtn.addEventListener('click', ()=>{ saveNameRow.style.display = 'flex'; nameInput.focus(); });
confirmSave.addEventListener('click', async ()=> { // Make function async
  const name=(nameInput.value||'Player').trim();
  if(!name){ alert('Please enter a name'); nameInput.focus(); return; }
  saveLocalScore(name, score, currentLevel); // Keep saving to local storage
  await saveFirebaseScore(name, score, currentLevel); // <--- NOW ALSO SAVE TO FIREBASE
  saveNameRow.style.display = 'none';
  nameInput.value='';
  renderLeaderboard(currentLevel); // Re-render local leaderboard as before
});

/* ---------- Orientation UI ---------- */
function evaluateOrientation(){
  const w=window.innerWidth, h=window.innerHeight;
  const isLandscape = w>=h;
  rotateOverlay.style.display = isLandscape ? 'none' : 'flex';
  return isLandscape;
}
window.addEventListener('orientationchange', ()=>setTimeout(()=>{sizeCanvas(); targetCenter={x:arenaRect.width/2,y:arenaRect.height/2};evaluateOrientation();},120));
window.addEventListener('resize', ()=>{sizeCanvas(); targetCenter={x:arenaRect.width/2,y:arenaRect.height/2}; drawTargetAndRings();});

/* ---------- Init ---------- */
(function init(){
  sizeCanvas();
  targetCenter = { x: arenaRect.width/2, y: arenaRect.height/2 };
  dotPos = { x: targetCenter.x, y: targetCenter.y };
  dotPos0 = {...dotPos};
  dotEl.style.left = dotPos.x+'px';
  dotEl.style.top = dotPos.y+'px';
  drawTargetAndRings();
  renderLeaderboard(1);
  evaluateOrientation();
  calibrateBtn.style.display = 'none';
  levelSelectionMenu.style.display = 'none';
  gameOverOverlay.style.display = 'none';
  
  // Hide game elements initially
  canvas.style.display = "none";
  dotEl.style.display = "none";
  scoreDisplay.style.display = "none";
  timerDisplay.style.display = "none";
})();
</script>
</body>
</html>
